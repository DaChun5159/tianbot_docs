import { ssrRenderAttrs, ssrRenderStyle } from "vue/server-renderer";
import { useSSRContext } from "vue";
import { _ as _export_sfc } from "./plugin-vue_export-helper.cc2b3d55.js";
const __pageData = JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"use_guide/tianbot_mini/guide/navigation/chapter1.md","filePath":"use_guide/tianbot_mini/guide/navigation/chapter1.md"}');
const _sfc_main = { name: "use_guide/tianbot_mini/guide/navigation/chapter1.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  _push(`<div${ssrRenderAttrs(_attrs)}><p style="${ssrRenderStyle({ "font-size": "30px", "font-weight": "bolder", "text-align": "center" })}">Move_Base 框架分析</p><h2 id="move-base" tabindex="-1">Move_Base <a class="header-anchor" href="#move-base" aria-label="Permalink to &quot;Move_Base&quot;">​</a></h2><p><img src="https://img.kancloud.cn/48/e6/48e6e3620e13dc386994d1208383882c_1194x553.png" alt=""></p><p>右部：</p><p>节点map_server 将地图信息，节点sensor sources将雷达信息、点云信息传至已在ROS系统中集成好的工装包集中，生成全局代价地图和局部代价地图。 左部：</p><p>提供定位和TF变换，将TF信息，和里程计信息，传至框内。amcl 是一个用于二维移动机器人的概率定位系统。它实现了自适应（或 KLD 采样）蒙特卡洛定位方法（如 Dieter Fox 所述），该方法使用粒子滤波器来跟踪机器人相对于已知地图的姿态。 上部：</p><p>目标点信息 goal 框内：</p><pre><code>全局代价地图进行全局路径规划
局部代价地图进行局部路径规划
先全局路径规划，后局部路径规划，最后控制机器人底盘信息，即控制机器人移动
</code></pre><h2 id="costmap" tabindex="-1">Costmap <a class="header-anchor" href="#costmap" aria-label="Permalink to &quot;Costmap&quot;">​</a></h2><p><a href="http://wiki.ros.org/costmap_2d" target="_blank" rel="noreferrer">http://wiki.ros.org/costmap_2d</a></p><p><img src="https://img.kancloud.cn/c2/03/c203a95b8a7ed1ac57fd0ef84a1ad3b0_236x207.png" alt=""></p><ul><li>图片来源<a href="http://wiki.ros.org/costmap_2d" target="_blank" rel="noreferrer">http://wiki.ros.org/costmap_2d</a></li></ul><p>上图中，四周的红色边界代表代价地图中的障碍物，蓝色单元格代表被机器人内接半径膨胀的障碍物，红色多边形代表机器人的足迹。*为了机器人避免碰撞，机器人的足迹不应与红色单元格相交，机器人的中心点不应与蓝色单元格相交</p><p><img src="https://img.kancloud.cn/9d/bb/9dbb64d6e6052656a154ea938a46c411_405x266.png" alt=""></p><ul><li>图片来源<a href="http://wiki.ros.org/costmap_2d" target="_blank" rel="noreferrer">http://wiki.ros.org/costmap_2d</a>* 翻译过来，也就是：</li></ul><p><img src="https://img.kancloud.cn/4e/53/4e53f5e294d2237a1a498bf8009e4963_1174x590.png" alt=""></p><h2 id="global-planner" tabindex="-1">Global_planner <a class="header-anchor" href="#global-planner" aria-label="Permalink to &quot;Global_planner&quot;">​</a></h2><p><a href="http://wiki.ros.org/global_planner" target="_blank" rel="noreferrer">http://wiki.ros.org/global_planner</a></p><p>接受的信息包括全局的地图以及起点和目标点</p><p>ROS官方导航功能包有Dijkstra和A*算法，默认Dijkstra</p><p>Dijkstra广度优先，A深度优先，Dijkstra算法计算源点到其他所有点的最短路径长度，A关注点到点的最短路径(包括具体路径)，Dijkstra算法的实质是广度优先搜索，是一种发散式的搜索，所以空间复杂度和时间复杂度都比较高。对路径上的当前点，A*算法不但记录其到源点的代价，还计算当前点到目标点的期望代价，是一种启发式算法 如图为Dijkstra广度优先</p><p><img src="https://img.kancloud.cn/97/45/97451dec269ee2469e06c3e152384197_398x282.png" alt=""></p><p>图片来源<a href="http://wiki.ros.org/global_planner" target="_blank" rel="noreferrer">http://wiki.ros.org/global_planner</a> 如图为A*深度优先</p><p><img src="https://img.kancloud.cn/b1/f3/b1f391e21df4a5caca8115ba1995e05b_398x282.png" alt=""></p><p>图片来源<a href="http://wiki.ros.org/global_planner" target="_blank" rel="noreferrer">http://wiki.ros.org/global_planner</a></p><p>Dijkstra能保证一定是最短最优路径，A*不一定</p><h2 id="local-planner" tabindex="-1">Local planner <a class="header-anchor" href="#local-planner" aria-label="Permalink to &quot;Local planner&quot;">​</a></h2><p><a href="http://wiki.ros.org/base_local_planner" target="_blank" rel="noreferrer">http://wiki.ros.org/base_local_planner</a></p><p>他接收全局路径规划器生成的路径，以及里程计的信息，地图信息，输出的是底盘运动的速度信息 先有全局路径规划器规划一条大致的路径，局部路径规划器把它分割成很多小段，再进行局部路径规划 在全局规划时对地图保存过的障碍物进行避障，在局部路径规划的时候会对新增的障碍物信息，也可以对运动的物体进行避障 DWA都是状态采样，先假设小车在什么位置，再根据这个位置的一系列状态信息，包括与退点的距离，与起点的距离，终点的距离，周围障碍物的信息等</p><h2 id="amcl" tabindex="-1">AMCL <a class="header-anchor" href="#amcl" aria-label="Permalink to &quot;AMCL&quot;">​</a></h2><p><a href="http://wiki.ros.org/amcl" target="_blank" rel="noreferrer">http://wiki.ros.org/amcl</a> 自适应蒙特卡洛定位，粒子滤波就是用了蒙特卡洛思想的方法，把粒子滤波用到定位上就叫做蒙特卡洛定位，粒子滤波包括初始化计算权重、重采样、状态转移</p><p><img src="https://img.kancloud.cn/d4/3f/d43f92ed070e0d434901e859f1c5c4d8_898x573.png" alt=""></p><p>开了导航节点的tf关系图，从map开始通过amcl广播，Map和odom combined的关系，再由ekf节点拓展卡尔曼功能包转换到小车的底座，拓展卡尔曼滤波处理的是里程计数据，</p><p><img src="https://img.kancloud.cn/e6/dc/e6dc905c5f39363fd66df0206b8c1b1a_1100x662.png" alt=""></p><ul><li>图片来源<a href="http://wiki.ros.org/amcl" target="_blank" rel="noreferrer">http://wiki.ros.org/amcl</a>*</li></ul><p>只处理里程计数据是无法完成定位的，没有办法关联到map上面，里程计只记录机器人走的路程，通过amcl处理后就可以完成，在地图上的定位关联上map</p></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("use_guide/tianbot_mini/guide/navigation/chapter1.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const chapter1 = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  chapter1 as default
};
